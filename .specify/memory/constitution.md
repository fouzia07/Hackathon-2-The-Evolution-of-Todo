<!--
Sync Impact Report:
Version: 1.0.0 (Initial constitution)
Modified principles: N/A (initial version)
Added sections:
  - Core Principles (8 principles)
  - Technical Standards
  - Phase Constraints
  - Governance
Removed sections: N/A
Templates status:
  ✅ plan-template.md - Constitution Check section aligns with principles
  ✅ spec-template.md - Requirements structure aligns with Spec-First principle
  ✅ tasks-template.md - Phase structure aligns with Incremental Evolution principle
Follow-up TODOs: None
-->

# AI-Native Spec-Driven Todo System Constitution

## Core Principles

### I. Spec-First Development

Every piece of code MUST originate from a written specification. No implementation work may begin without a completed spec document that defines requirements, user stories, and acceptance criteria.

**Rationale**: Prevents scope creep, ensures traceability, and enables AI agents to work from clear, documented requirements rather than implicit assumptions.

**Non-Negotiable Rules**:
- All features require `spec.md` before any code is written
- Changes to existing features require spec updates before implementation
- No "quick fixes" that bypass specification process

### II. No Manual Coding

All code MUST be generated by AI agents. Human developers may review, approve, and guide AI agents, but direct manual code writing is prohibited.

**Rationale**: Enforces consistency with the AI-native development model, ensures reproducibility through prompt history, and validates that specifications are clear enough for autonomous AI execution.

**Non-Negotiable Rules**:
- Code changes must be traceable to AI agent execution
- Manual edits require justification and re-specification
- Emergency hotfixes must be retrospectively documented and re-generated by agents

### III. Agentic Execution Model

Development work MUST be performed by specialized AI agents with defined roles and capabilities as documented in the project's agent definitions.

**Rationale**: Distributes responsibility across specialized agents (architecture, implementation, testing), maintains separation of concerns, and enables parallel execution of independent tasks.

**Non-Negotiable Rules**:
- Each agent operates within its defined surface area
- Agent interactions follow documented protocols
- Cross-agent dependencies must be explicitly declared

### IV. Incremental Evolution

Features MUST progress through ordered phases, with each phase building on the previous phase's deliverables. No phase may be skipped.

**Rationale**: Manages complexity, enables validation at each stage, and ensures foundational capabilities exist before dependent features are built.

**Non-Negotiable Rules**:
- Phase I (CLI) must be complete before Phase II (Web) begins
- Phase II (Web) must be complete before Phase III (AI Chatbot) begins
- Phase III (AI Chatbot) must be complete before Phase IV (Local K8s) begins
- Phase IV (Local K8s) must be complete before Phase V (Cloud) begins
- Each phase requires functional validation before progression

### V. Reproducibility Through Documentation

Every development action MUST be recorded in prompt history records (PHRs) and architectural decision records (ADRs). This enables full reconstruction of the development process.

**Rationale**: Allows auditing of AI decisions, enables learning from past patterns, supports debugging by tracing decisions to their origin, and facilitates onboarding of new agents or humans.

**Non-Negotiable Rules**:
- PHR created for every user interaction that results in code or spec changes
- Architectural decisions documented in ADRs when significance threshold is met
- All prompts and agent responses preserved in `history/` directory
- No deletion of historical records without explicit approval

### VI. Cloud-Native Architecture

System architecture MUST be stateless, containerized, and designed for distributed execution. Persistent state resides only in managed services (databases, event streams).

**Rationale**: Enables horizontal scaling, simplifies deployment, supports event-driven patterns, and aligns with modern cloud-native practices.

**Non-Negotiable Rules**:
- Application code must be stateless
- State persistence via PostgreSQL/Neon database only
- Event-driven communication via Kafka (Dapr binding)
- All services must be containerizable with Docker
- Kubernetes deployment configurations required for Phase IV and beyond

### VII. Technology Stack Consistency

All components MUST use the approved technology stack. Deviations require constitutional amendment through governance process.

**Rationale**: Reduces cognitive load on agents, ensures interoperability, simplifies dependency management, and maintains consistency across all phases.

**Approved Technologies**:
- **Backend**: Python 3.11+ with FastAPI framework
- **Frontend**: Next.js (React-based)
- **Database**: PostgreSQL (via Neon for cloud, local for development)
- **AI/LLM**: OpenAI Agents with MCP (Model Context Protocol)
- **Containerization**: Docker
- **Orchestration**: Kubernetes (Minikube for local, managed service for cloud)
- **Eventing**: Kafka via Dapr bindings
- **Authentication**: JWT tokens
- **Repository Structure**: Monorepo with `/specs` directory for all specifications

### VIII. Phase-Specific Constraints

Each development phase has mandatory constraints that define its scope and limitations:

**Phase I – CLI (In-Memory CRUD)**:
- Must implement core CRUD operations (Create, Read, Update, Delete)
- Data storage: in-memory only (no database)
- Interface: command-line only
- State: transient (lost on application exit)
- Testing: unit tests for CLI commands

**Phase II – Web (Database + Authentication)**:
- Must persist data to PostgreSQL database
- Must implement JWT-based authentication
- Must provide REST API (FastAPI backend)
- Must provide web UI (Next.js frontend)
- Testing: integration tests for API + UI workflows

**Phase III – AI Chatbot (Natural Language Interface)**:
- Must accept natural language input for todo operations
- Must integrate OpenAI Agents with MCP
- Must support conversational context
- Must map natural language to CRUD operations
- Testing: NLP intent recognition accuracy tests

**Phase IV – Local Kubernetes (Container Orchestration)**:
- Must deploy on Minikube (local K8s)
- Must use Helm charts for deployment
- Must configure service discovery
- Must implement health checks and readiness probes
- Testing: deployment validation, pod lifecycle tests

**Phase V – Cloud (Event-Driven + CI/CD)**:
- Must deploy to managed cloud Kubernetes (e.g., GKE, EKS, AKS)
- Must implement event-driven architecture via Kafka + Dapr
- Must establish CI/CD pipeline for automated deployment
- Must configure monitoring and alerting
- Testing: end-to-end cloud deployment validation

## Technical Standards

### Code Quality

- All code must pass linting checks (Black for Python, ESLint for JavaScript/TypeScript)
- Type hints required for all Python functions (PEP 484)
- TypeScript strict mode required for frontend code
- Cyclomatic complexity must not exceed 10 per function
- Code coverage minimum 80% for business logic

### Testing Requirements

- Unit tests for all business logic
- Integration tests for all API endpoints
- Contract tests for inter-service communication
- End-to-end tests for critical user journeys
- Performance tests for endpoints exceeding 100ms target

### Security Standards

- No secrets or credentials in source code
- Environment variables via `.env` files (excluded from version control)
- JWT tokens expire within 24 hours
- All API endpoints require authentication (except public health checks)
- Input validation on all user-supplied data
- SQL injection prevention via parameterized queries

### Performance Requirements

- API response time p95 < 200ms
- Database query execution < 50ms
- Frontend initial page load < 2 seconds
- Frontend interaction response < 100ms
- Container startup time < 10 seconds

## Phase Constraints

Development MUST proceed through phases in order:

1. **Phase I – CLI**: In-memory CRUD operations via command-line interface
2. **Phase II – Web**: Persistent storage (PostgreSQL) + authentication (JWT) + web UI (Next.js)
3. **Phase III – AI Chatbot**: Natural language interface via OpenAI Agents + MCP
4. **Phase IV – Local K8s**: Minikube deployment + Helm charts
5. **Phase V – Cloud**: Event-driven architecture + CI/CD + managed Kubernetes

Each phase requires:
- Complete `spec.md` (user stories, requirements, acceptance criteria)
- Complete `plan.md` (architecture, technical decisions, structure)
- Complete `tasks.md` (implementation tasks with dependencies)
- Functional validation before next phase begins

## Governance

### Constitutional Authority

This constitution supersedes all other project practices and guidelines. All development decisions must align with these principles.

### Amendment Process

Constitutional amendments require:
1. Written proposal documenting rationale and impact
2. Validation that change does not violate higher-order principles
3. Update to this document with version increment
4. Migration plan for affected artifacts (specs, plans, tasks)
5. Update to all dependent templates and tooling

### Versioning Policy

Constitution version follows semantic versioning (MAJOR.MINOR.PATCH):
- **MAJOR**: Backward-incompatible changes (principle removal, redefinition)
- **MINOR**: New principles or sections added
- **PATCH**: Clarifications, wording improvements, non-semantic fixes

### Compliance

- All pull requests must verify constitutional compliance
- Complexity violations require explicit justification in `plan.md`
- Agents must reference constitution principles when making architectural decisions
- Periodic audits to ensure adherence (at phase transitions)

### Documentation Structure

All project documentation follows this structure:

```
specs/
├── [###-feature-name]/
│   ├── spec.md              # Feature specification
│   ├── plan.md              # Implementation plan
│   ├── tasks.md             # Task breakdown
│   ├── research.md          # Research findings
│   ├── data-model.md        # Data models
│   └── contracts/           # API contracts

history/
├── prompts/
│   ├── constitution/        # Constitution-related prompts
│   ├── [feature-name]/      # Feature-specific prompt history
│   └── general/             # General development prompts
└── adr/                     # Architecture Decision Records

.specify/
├── memory/
│   └── constitution.md      # This file
├── templates/               # Document templates
└── scripts/                 # Automation scripts
```

### Runtime Development Guidance

For detailed agent-specific operational guidelines, see:
- `CLAUDE.md` - Claude Code agent instructions
- `.specify/templates/commands/*.md` - Command-specific workflows
- `AGENTS.md` - Agent role definitions (to be created)

**Version**: 1.0.0 | **Ratified**: 2026-01-02 | **Last Amended**: 2026-01-02
